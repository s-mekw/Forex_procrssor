# 要件仕様書

## 概要
Forex_procrssorは、FX取引における価格予測と自動化を実現する、機械学習ベースの統合取引支援システムです。MetaTrader 5との直接統合により低遅延なデータ取得を実現し、Polarsによる高速データ処理、PatchTSTモデルによる高精度な時系列予測、InfluxDBでの効率的なデータ永続化、そしてDashによるインタラクティブな可視化を提供します。

## 要件

## 機能1: MT5データ取得基盤

### 要件1.1: MT5クライアント接続管理
**ユーザーストーリー:** システム管理者として、MT5ソフトウェアとの安定した接続を維持し、接続の問題を適切に処理したい。

#### 受け入れ条件
1. WHEN MT5に接続する THEN MT5ソフトウェアの認証済みセッションを利用してAPI接続を確立する
2. WHEN 接続が確立される THEN ターミナル情報とアカウント情報をログに出力する
3. WHEN 接続が失敗する THEN MT5ソフトウェアの起動状態を確認し、指数バックオフ戦略で最大5回まで再接続を試行する
4. WHEN 接続がタイムアウトする THEN 30秒のタイムアウト設定で処理する
5. IF 全ての再接続が失敗 THEN カスタム例外（MT5ConnectionError）を発生させ、MT5ソフトウェアの状態確認を促す

### 要件1.2: リアルタイムティックデータ取得
**ユーザーストーリー:** FXトレーダーとして、遅延なく正確な価格情報を取得し、瞬時の市場変動を捉えたい。

#### 受け入れ条件
1. WHEN ティックデータを要求する THEN 指定通貨ペアの最新Bid/Askを取得する
2. WHEN ティックデータが受信される THEN タイムスタンプ、Bid、Ask、Volumeを含む構造化データに変換する
3. WHEN 新しいティックが到着する THEN 10ミリ秒以内にイベントをトリガーする
4. WHEN 価格データが異常値を示す THEN スパイクフィルターで異常値を検出・除外する
5. IF データストリームが中断される THEN 自動的に再購読を実行する

### 要件1.3: 履歴OHLCデータ取得
**ユーザーストーリー:** FXトレーダーとして、過去の価格パターンを分析するために、効率的に履歴データを取得したい。

#### 受け入れ条件
1. WHEN 履歴データを要求する THEN MT5から直接OHLC形式でデータを取得する
2. WHEN 大量データを取得する THEN 10,000バー単位でバッチ処理を実行する
3. WHEN データ範囲を指定する THEN 開始日時と終了日時の範囲内データを取得する
4. WHEN 複数時間足を要求する THEN 1分、5分、15分、30分、1時間、4時間、日足に対応する
5. IF データが欠損している THEN 欠損期間を特定し、ログに記録する

### 要件1.4: ティック→バー変換エンジン
**ユーザーストーリー:** FXトレーダーとして、リアルタイムティックから任意の時間足バーを生成し、統一された分析環境を構築したい。

#### 受け入れ条件
1. WHEN ティックデータが蓄積される THEN リアルタイムで1分足OHLCバーを生成する
2. WHEN バーが完成する THEN Open、High、Low、Close、Volume、Timestampを含む完全なバー情報を作成する
3. WHEN 未完成バーが存在する THEN 現在価格で継続的にHigh/Lowを更新する
4. WHEN 新しい時間足が開始される THEN 前のバーを確定し、新しいバーを初期化する
5. IF ティック間隔が30秒を超える THEN データ欠損警告を発出する

## 機能2: 高速データ処理パイプライン

### 要件2.1: Polarsデータ処理基盤
**ユーザーストーリー:** システム開発者として、高速で効率的なデータ処理を実現し、大量の価格データを短時間で処理したい。

#### 受け入れ条件
1. WHEN データフレーム操作を実行する THEN 全ての処理でPolarsを使用し、Pandasは使用禁止とする
2. WHEN 大量データを処理する THEN LazyFrameを活用して遅延評価で最適化する
3. WHEN データ型を定義する THEN スキーマを明示的に定義してメモリ使用量を最適化する
4. WHEN データ構造を共通化する THEN src/common/にPydanticモデル等で共有スキーマを定義し、コンポーネント間のデータ一貫性を保証する
5. WHEN 並列処理が可能 THEN CPUコア数に応じて並列実行する
6. IF メモリ不足が予想される THEN ストリーミング処理に切り替える

### 要件2.2: テクニカル指標計算エンジン
**ユーザーストーリー:** FXトレーダーとして、多様なテクニカル指標を高速に計算し、市場分析の精度を向上させたい。

#### 受け入れ条件
1. WHEN EMA計算を実行する THEN 5、20、50、100、200期間のEMAを同時計算する
2. WHEN polars-ta-extensionを使用する THEN ネイティブPolars表現で高速計算を実現する
3. WHEN 指標更新が要求される THEN 新しいデータポイントのみで増分計算を実行する
4. WHEN 複数指標を組み合わせる THEN 効率的なパイプライン処理で一括計算する
5. IF 計算エラーが発生 THEN エラー詳細をログに記録し、デフォルト値で継続する

### 要件2.3: RCI計算エンジン
**ユーザーストーリー:** FXトレーダーとして、カスタマイズ可能な複数期間のRCIを利用して相場の過熱感を多角的に分析したい。

#### 受け入れ条件
1. WHEN RCI計算を実行する THEN ユーザー設定可能な期間リスト（デフォルト: 9、13、24、33、48、66、108、120、165、240、330、540）でRCIを計算する
2. WHEN ユーザーがRCI期間を変更する THEN 設定ファイルまたはUI経由で期間リストを動的に更新する
3. WHEN ランキング処理を実行する THEN Polars Expression統合による高速ランク計算を実行する
4. WHEN 汎用RCI計算を実行する THEN 期間パラメータ化されたエンジンで任意期間（3〜200期間）に対応する
5. WHEN RCI値を出力する THEN -100から+100の範囲で正規化された値を提供する
6. IF 期間内データが不足 THEN 利用可能なデータで部分RCIを計算し、信頼性フラグを設定する
7. IF 無効な期間が設定される THEN 有効範囲（3〜200期間）内に制限し、警告メッセージを表示する

### 要件2.4: リアルタイム処理パイプライン
**ユーザーストーリー:** システム管理者として、リアルタイムデータフローを安定して処理し、遅延を最小化したい。

#### 受け入れ条件
1. WHEN データが到着する THEN 非同期処理でリアルタイム更新を実行する
2. WHEN 処理キューが蓄積する THEN バックプレッシャー制御で負荷を調整する
3. WHEN 複数データソースがある THEN ストリーム結合でデータを統合する
4. WHEN エラーが発生する THEN 障害隔離で他の処理に影響しないように処理する
5. IF 処理遅延が1秒を超える THEN 遅延アラートを発出し、処理優先度を調整する

### 要件2.5: マルチタイムフレーム分析エンジン
**ユーザーストーリー:** FXトレーダーとして、計算負荷を最適化しつつ、短期および長期の市場トレンドを効率的に分析したい。

#### 受け入れ条件
1. WHEN リアルタイムパイプラインが1分足データを受信する THEN 5分足データを動的に生成（ダウンサンプリング）する
2. WHEN OHLCバーを生成する THEN 1分足から5分足のOHLCを`group_by_dynamic`で集約する (Open: first, High: max, Low: min, Close: last)
3. WHEN 短期RCIを計算する THEN 1分足データを使用して、設定された短期期間（例: 9, 13, 24, 33, 48, 66, 108）で計算する
4. WHEN 長期RCIを計算する THEN 動的に生成された5分足データを使用して、設定された長期期間（例: 120期間の代わりに24期間）で計算する
5. WHEN 分析結果を統合する THEN 異なる時間足で計算されたRCI結果を、元の1分足のタイムスタンプに揃えて統合する
6. IF データが不足している場合 THEN 5分足バーが確定するまで、計算を保留する

## 機能3: 時系列データストレージ

### 要件3.1: InfluxDBデータ永続化
**ユーザーストーリー:** データアナリストとして、大量の時系列データを効率的に保存し、高速検索を実現したい。

#### 受け入れ条件
1. WHEN InfluxDBに接続する THEN 環境変数（INFLUXDB_URL, INFLUXDB_TOKEN, INFLUXDB_ORG, INFLUXDB_BUCKET）で設定する
2. WHEN データを書き込む THEN バッチサイズ1000ポイントで効率的に一括書き込みする
3. WHEN タグを設定する THEN 通貨ペア、時間足、データタイプでタグ付けする
4. WHEN クエリを実行する THEN Flux言語で高速な時系列クエリを実行する
5. IF 書き込みエラーが発生 THEN 再試行キューに格納し、後で再処理する

### 要件3.2: Parquetアーカイブシステム
**ユーザーストーリー:** システム管理者として、長期間のデータを効率的にアーカイブし、必要時に高速アクセスしたい。

#### 受け入れ条件
1. WHEN データが1ヶ月経過する THEN 自動的にParquet形式でアーカイブする
2. WHEN Parquetファイルを作成する THEN 列指向形式で最大圧縮率を実現する
3. WHEN アーカイブデータにアクセスする THEN Polarsで高速読み込みを実行する
4. WHEN ファイル分割を実行する THEN 通貨ペア・年月単位でパーティション化する
5. IF アーカイブ処理が失敗 THEN 元データを保持し、エラーアラートを送信する

### 要件3.3: データクエリエンジン
**ユーザーストーリー:** FXトレーダーとして、複雑な条件で過去データを検索し、迅速な分析を実行したい。

#### 受け入れ条件
1. WHEN データクエリを実行する THEN InfluxDBとParquetの両方から統合検索する
2. WHEN 時間範囲クエリを実行する THEN インデックスを活用して10ミリ秒以内で結果を返す
3. WHEN 集計クエリを実行する THEN ダウンサンプリングで効率的な集計処理を実行する
4. WHEN 複数条件を指定する THEN ANDORフィルタリングでコンプレックスクエリに対応する
5. IF クエリがタイムアウトする THEN 部分結果を返し、残りの処理を継続する
6. WHEN 頻繁に同じクエリが実行される THEN Redisキャッシュ層を利用して応答を高速化し、DB負荷を軽減する

### 要件3.4: データ整合性管理
**ユーザーストーリー:** システム管理者として、データの整合性を保ち、データ破損や欠損を防止したい。

#### 受け入れ条件
1. WHEN データを書き込む THEN チェックサムを計算してデータ整合性を検証する
2. WHEN 重複データを検出する THEN タイムスタンプとシンボルでユニーク制約を適用する
3. WHEN データバックアップを実行する THEN 日次で自動バックアップを実行する
4. WHEN データリストアを実行する THEN ポイントインタイム復旧で指定時点にリストアする
5. IF データ不整合を検出 THEN 自動修復を試行し、修復不可能な場合はアラートを送信する
6. WHEN 整合性検証ロジックを設定する THEN チェックサムアルゴリズムやサーキットブレーカーの閾値を設定ファイルで外部から変更可能にする
7. WHEN 依存コンポーネントを管理する THEN 依存性注入（DI）パターンを用いて、テスト容易性と保守性を向上させる


## 機能4: PatchTST機械学習モデル

### 要件4.1: ML環境・基盤設定
**ユーザーストーリー:** ML開発者として、最適化された学習環境でモデルを効率的に開発・運用したい。

#### 受け入れ条件
1. WHEN ML環境を初期化する THEN PyTorch + CUDAで GPU加速環境を構築する
2. WHEN neuralforecastを使用する THEN 時系列特化ライブラリで高精度予測を実現する
3. WHEN TensorBoardを起動する THEN ポート6006で可視化ダッシュボードを提供する
4. WHEN モデルを保存する THEN ./models/ディレクトリにバージョン管理で保存する
5. IF GPUが利用不可 THEN CPUモードに自動フォールバックし、警告を表示する

### 要件4.2: PatchTSTモデル実装
**ユーザーストーリー:** ML開発者として、最新のTransformerアーキテクチャで高精度な時系列予測を実現したい。

#### 受け入れ条件
1. WHEN PatchTSTモデルを構築する THEN Nixtla NeuralForecast の `PatchTST` を採用し、パッチベースの効率的なTransformerアーキテクチャを実装する
2. WHEN モデルの特徴量を定義する THEN 価格データ（OHLC、ただしVolumeは除外）と算出されたテクニカル指標（EMA、RCI等）を入力特徴量として使用する
3. WHEN ハイパーパラメータを設定する THEN パッチサイズ、隠れ層次元、注意ヘッド数を最適化する
4. WHEN 複数ホライズン予測を実行する THEN 1分〜15分先まで（1分刻み・15ステップ）のマルチホライズン予測を実現する
5. WHEN 出力ターゲットを定義する THEN デフォルトは終値のみを予測対象とする（オプションで「終値＋1分24RCI＋1分48RCI」の3出力を許容）
6. WHEN 不確実性を定量化する THEN 予測区間（80%、90%、95%）を分位回帰で出力する（`quantile_levels=[0.5,0.8,0.9,0.95]`）。量子化交差を防ぐ単調性担保を行う
7. WHEN データ形式を定義する THEN NeuralForecast規約のlong-form（`unique_id`, `ds`, `y`）を採用し、履歴外生は `hist_exog_list` に渡す。`freq='T'` を設定する
8. WHEN 前処理を定義する THEN z-score正規化（学習時統計を推論時に使用）、欠損は前方補完＋必要に応じ欠損フラグ列を付与する
9. WHEN 実装ポリシーを定義する THEN データ処理はPolars優先、NeuralForecast呼び出し直前のみPandasへ変換する
10. WHEN 出力仕様を定義する THEN 出力形状は `[B, 15, Q]` とし、`quantile_levels` をメタデータとして併送する（列名はNF標準に準拠）
11. WHEN 実行環境を設定する THEN PyTorch Lightningの `trainer_kwargs` で GPU/CPU を自動選択し、デバイス1・`precision='32-true'` を既定とする
12. IF モデル読み込みに失敗 THEN デフォルトパラメータで新しいモデルを初期化する

### 要件4.3: 自動学習・再学習システム
**ユーザーストーリー:** システム管理者として、モデルの性能を自動的に監視し、必要に応じて再学習を実行したい。

#### 受け入れ条件
1. WHEN 学習データが蓄積される THEN 最低1000時間分のデータで初回学習を開始する
2. WHEN モデル性能が低下する THEN MAPE（平均絶対パーセント誤差）5%悪化で再学習をトリガーする
3. WHEN 新しいデータが利用可能 THEN 増分学習で既存モデルを更新する
4. WHEN 学習を実行する THEN 検証データ分割（80%学習、20%検証）で評価する
5. IF 学習が失敗 THEN 前回の安定モデルを保持し、エラーアラートを送信する

### 要件4.4: リアルタイム推論エンジン
**ユーザーストーリー:** FXトレーダーとして、最新データに基づいてリアルタイムで価格予測を取得したい。

#### 受け入れ条件
1. WHEN 推論リクエストを受信する THEN 200ミリ秒以内で予測結果を返す
2. WHEN 複数通貨ペアの推論を実行する THEN バッチ推論で効率的に並列処理する
3. WHEN 予測結果を出力する THEN 予測値、信頼区間、信頼度スコアを含む構造化データを提供する
4. WHEN 推論モデルを更新する THEN ホットスワップで無停止モデル更新を実行する
5. IF 推論エラーが発生 THEN 前回の予測値を返し、エラーログを記録する

### 要件4.5: モデル評価・監視
**ユーザーストーリー:** ML開発者として、モデルの性能を継続的に監視し、予測精度を改善したい。

#### 受け入れ条件
1. WHEN モデル評価を実行する THEN MAPE、RMSE、MAEの複数指標で性能を測定する
2. WHEN ドリフト検出を実行する THEN 統計的手法でデータドリフトを監視する
3. WHEN 特徴量重要度を計算する THEN SHAP値で予測への貢献度を可視化する
4. WHEN A/Bテストを実行する THEN 複数モデルで予測性能を比較評価する
5. IF 予測精度が閾値を下回る THEN アラートを発出し、モデル再構築を推奨する

## 機能5: インタラクティブダッシュボード

### 要件5.1: Dashアプリケーション基盤
**ユーザーストーリー:** FXトレーダーとして、直感的で応答性の高いWebインターフェースで市場データを監視したい。

#### 受け入れ条件
1. WHEN Dashアプリを起動する THEN ポート8050でWebサーバーを開始する
2. WHEN レイアウトを構築する THEN モジュラー設計でコンポーネントを組み合わせる
3. WHEN ユーザーインタラクションを処理する THEN コールバック関数でリアクティブUI を実現する
4. WHEN 複数ページを提供する THEN メインダッシュボード、設定、統計ページを提供する
5. IF 初期化エラーが発生 THEN デフォルト設定でフォールバックモードで起動する

### 要件5.2: リアルタイムチャート表示
**ユーザーストーリー:** FXトレーダーとして、ローソク足チャートと予測線をリアルタイムで確認し、市場変動を即座に把握したい。

#### 受け入れ条件
1. WHEN チャートを表示する THEN Plotlyでインタラクティブなローソク足チャートを描画する
2. WHEN 新しいデータが到着する THEN チャートを自動更新し、最新状態を維持する
3. WHEN 複数時間足を表示する THEN タブまたはドロップダウンで時間足を切り替える
4. WHEN AI予測を描画する THEN 予測線と信頼区間を異なる色・透明度で重ねて表示する
5. IF チャート描画に失敗 THEN エラーメッセージを表示し、キャッシュデータで代替表示する

### 要件5.3: WebSocketリアルタイム通信
**ユーザーストーリー:** FXトレーダーとして、ページリロードなしで最新データを受信し、滑らかなユーザー体験を得たい。

#### 受け入れ条件
1. WHEN WebSocket接続を確立する THEN dash-extensionsでリアルタイム通信を実現する
2. WHEN データ更新イベントが発生する THEN 全接続クライアントに更新を配信する
3. WHEN 接続が切断される THEN 自動再接続を試行し、接続状態をUI に表示する
4. WHEN 複数クライアントが接続する THEN 効率的なブロードキャスト配信を実行する
5. IF WebSocketエラーが発生 THEN ポーリング方式にフォールバックする

### 要件5.4: カスタマイズ可能UI
**ユーザーストーリー:** FXトレーダーとして、個人の取引スタイルに合わせてダッシュボードをカスタマイズしたい。

#### 受け入れ条件
1. WHEN レイアウトを変更する THEN ドラッグ&ドロップでウィジェットを配置する
2. WHEN 表示設定を変更する THEN 通貨ペア、時間足、指標の表示/非表示を切り替える
3. WHEN テーマを変更する THEN ダーク/ライトテーマで外観を切り替える
4. WHEN 設定を保存する THEN ブラウザローカルストレージで設定を永続化する
5. IF 設定読み込みに失敗 THEN デフォルト設定を適用し、エラーメッセージを表示する

### 要件5.5: パフォーマンス最適化
**ユーザーストーリー:** FXトレーダーとして、大量データ表示時でも快適な操作性を維持したい。

#### 受け入れ条件
1. WHEN 大量データを表示する THEN 仮想スクロールで表示範囲のみを描画する
2. WHEN チャート更新を実行する THEN 差分更新で必要な部分のみを再描画する
3. WHEN メモリ使用量を最適化する THEN データポイント制限で古いデータを破棄する
4. WHEN 応答性を改善する THEN Web Workerでバックグラウンド処理を実行する
5. IF フレームレートが30fps を下回る THEN 更新頻度を調整し、パフォーマンスを維持する

## 機能6: 本番運用・監視

### 要件6.1: システム監視・ヘルスチェック
**ユーザーストーリー:** システム管理者として、システムの健全性を継続的に監視し、問題を早期発見したい。

#### 受け入れ条件
1. WHEN ヘルスチェックを実行する THEN 全コンポーネント（MT5、InfluxDB、ML）の状態を確認する
2. WHEN システムメトリクスを収集する THEN CPU、メモリ、ディスク、ネットワーク使用率を監視する
3. WHEN アプリケーションメトリクスを収集する THEN レスポンス時間、エラー率、スループットを測定する
4. WHEN 異常を検出する THEN 閾値ベース・異常検知アルゴリズムで問題を識別する
5. IF 重要コンポーネントが停止 THEN 緊急アラートを発出し、自動復旧を試行する

### 要件6.2: ログ管理・構造化ログ
**ユーザーストーリー:** システム管理者として、問題調査とデバッグを効率的に実行するために、包括的なログを管理したい。

#### 受け入れ条件
1. WHEN ログを出力する THEN JSON形式の構造化ログで統一する
2. WHEN ログレベルを設定する THEN DEBUG、INFO、WARNING、ERROR、CRITICALの5段階を使用する
3. WHEN ログローテーションを実行する THEN 日次で自動ローテーションし、古いログを圧縮保存する
4. WHEN 分散トレーシングを実行する THEN リクエストIDでエンドツーエンドのトレースを実現する
5. IF ログ出力エラーが発生 THEN フォールバック先にログを出力し、ログ欠損を防止する
6. WHEN データ修復処理を実行する THEN 修復プロセスの各ステップ（試行、成功、失敗）で詳細な構造化ログを出力し、問題発生時の追跡を容易にする


### 要件6.3: エラーハンドリング・例外管理
**ユーザーストーリー:** システム開発者として、予期しないエラーを適切に処理し、システムの安定性を確保したい。

#### 受け入れ条件
1. WHEN カスタム例外を定義する THEN ドメイン固有の例外クラスで明確なエラー分類を実現する
2. WHEN 例外が発生する THEN 詳細なスタックトレースとコンテキスト情報をログに記録する
3. WHEN 自動復旧を実行する THEN 再試行、フォールバック、サーキットブレーカーパターンを適用する
4. WHEN ユーザーにエラーを通知する THEN 技術的詳細を隠し、理解しやすいメッセージを表示する
5. IF 致命的エラーが発生 THEN graceful shutdownで安全にシステムを停止する

### 要件6.4: セキュリティ・認証
**ユーザーストーリー:** システム管理者として、不正アクセスを防止し、機密データを保護したい。

#### 受け入れ条件
1. WHEN 認証情報を管理する THEN 環境変数で機密情報を管理し、コードにハードコーディングしない
2. WHEN API にアクセスする THEN トークンベース認証でアクセス制御を実行する
3. WHEN データを送信する THEN HTTPS/TLS暗号化で通信を保護する
4. WHEN 入力を検証する THEN 全ての外部入力に対してバリデーションを実行する
5. IF 不正アクセスを検出 THEN IPブロック・アクセス制限で攻撃を遮断する

### 要件6.5: パフォーマンス監視・最適化
**ユーザーストーリー:** システム管理者として、システムパフォーマンスを継続的に監視し、ボトルネックを特定したい。

#### 受け入れ条件
1. WHEN パフォーマンスを測定する THEN APM（Application Performance Monitoring）ツールで詳細分析する
2. WHEN ボトルネックを特定する THEN プロファイリングで処理時間の内訳を分析する
3. WHEN リソース使用率を監視する THEN リアルタイムメトリクスで使用状況を可視化する
4. WHEN 最適化を実行する THEN データベースクエリ、メモリ使用量、I/O処理を改善する
5. IF パフォーマンス低下を検出 THEN 自動スケーリング・負荷分散で対応する
6. WHEN クエリエンジンを監視する THEN クエリ実行時間、キャッシュヒット/ミス率をPrometheusで監視する

### 要件6.6: バックアップ・災害復旧
**ユーザーストーリー:** システム管理者として、データ損失とシステム障害に備えて、包括的な災害復旧計画を実装したい。

#### 受け入れ条件
1. WHEN データバックアップを実行する THEN 日次で自動バックアップし、3-2-1ルールに従う
2. WHEN 構成バックアップを実行する THEN システム設定、環境変数、デプロイメント構成を保存する
3. WHEN 災害復旧を実行する THEN RTO（目標復旧時間）4時間、RPO（目標復旧ポイント）1時間で復旧する
4. WHEN 復旧テストを実行する THEN 月次で復旧手順をテストし、有効性を確認する
5. IF 完全システム障害が発生 THEN バックアップサイトで自動フェイルオーバーを実行する

## 追加要件: 統合・拡張性

### 要件7.1: マルチ通貨ペア・スケーラビリティ
**ユーザーストーリー:** FXトレーダーとして、複数の通貨ペアを効率的に監視し、市場全体の動向を把握したい。

#### 受け入れ条件
1. WHEN 通貨ペアを追加する THEN 動的設定で新しいペアのデータ取得を開始する
2. WHEN 並列処理を実行する THEN 通貨ペア単位でワーカープロセスを分散実行する
3. WHEN リソースを管理する THEN 優先度ベースで処理リソースを動的割り当てする
4. WHEN スケールアウトする THEN 水平スケーリングで複数インスタンスに負荷分散する
5. IF メモリ制限に到達 THEN 低優先度ペアを一時停止し、アラートを発出する

### 要件7.2: APIエンドポイント・外部統合
**ユーザーストーリー:** システム開発者として、外部システムとの統合を容易にするために、RESTful APIを提供したい。

#### 受け入れ条件
1. WHEN APIを提供する THEN OpenAPI仕様に準拠したRESTful APIエンドポイントを実装する
2. WHEN データにアクセスする THEN JSON形式で構造化されたレスポンスを返す
3. WHEN レート制限を適用する THEN API キー単位で時間あたりのリクエスト数を制限する
4. WHEN API ドキュメントを提供する THEN Swagger UIで対話的なAPI ドキュメントを生成する
5. IF API エラーが発生 THEN HTTP ステータスコードと詳細エラーメッセージを返す

### 要件7.3: バックテスト・戦略検証
**ユーザーストーリー:** FXトレーダーとして、過去データを使用して取引戦略を検証し、最適なパラメータを発見したい。

#### 受け入れ条件
1. WHEN バックテスト期間を設定する THEN 開始日・終了日を指定して過去データを取得する
2. WHEN 取引戦略を定義する THEN エントリー・エグジット条件を設定可能にする
3. WHEN バックテストを実行する THEN 手数料、スプレッド、スリッページを考慮したリアルな計算を実行する
4. WHEN 結果を分析する THEN 総収益、勝率、最大ドローダウン、シャープレシオを計算する
5. WHEN 戦略の頑健性を評価する THEN ウォークフォワード分析をサポートし、時系列での性能を検証する
6. WHEN 戦略パラメータを最適化する THEN グリッドサーチやベイズ最適化の手法を用いて、最適なパラメータセットを自動探索する
7. IF 計算エラーが発生 THEN 部分結果を表示し、エラー詳細をログに記録する

### 要件7.4: アラート・通知システム
**ユーザーストーリー:** FXトレーダーとして、重要な市場変動や取引機会を即座に通知を受けて、機会を逃さないようにしたい。

#### 受け入れ条件
1. WHEN 価格アラートを設定する THEN 指定価格到達時にリアルタイムアラートを発出する
2. WHEN テクニカルアラートを設定する THEN 指標条件（EMA クロス、RCI過熱等）でアラートをトリガーする
3. WHEN AI予測アラートを設定する THEN 予測値の大幅変動時にアラートを送信する
4. WHEN システムアラートを送信する THEN 接続断、エラー発生時に管理者に緊急通知する
5. IF アラート送信に失敗 THEN 代替手段（ログ、ローカル通知）でフォールバックする

### 要件7.5: 設定管理・ユーザー設定
**ユーザーストーリー:** FXトレーダーとして、個人の取引スタイルに合わせてシステム設定をカスタマイズしたい。

#### 受け入れ条件
1. WHEN 設定を一元管理する THEN src/config/settings.tomlのような単一ファイルで、テクニカル指標の期間、通貨ペア、各種閾値などを管理する
2. WHEN 通貨ペア設定を変更する THEN 監視対象ペアをリストで管理・更新する
3. WHEN アラート設定を変更する THEN 閾値、通知方法、優先度を個別に設定する
4. WHEN 表示設定を変更する THEN チャートの色、時間足、指標表示をカスタマイズする
5. WHEN 設定を保存する THEN TOML等の設定ファイルで永続化し、起動時に読み込む
6. IF 設定ファイルが破損 THEN デフォルト設定で初期化し、バックアップから復元を試行する
7. WHEN クエリエンジン設定を変更する THEN ホットデータ保持期間や同時クエリ数などのパラメータを設定ファイルから動的に読み込む
8. WHEN データ整合性パラメータを変更する THEN チェックサムアルゴリズムやサーキットブレーカーの閾値を `settings.toml` から動的に読み込む